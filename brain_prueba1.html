<html>
  <head>
    <title>Cerebro 3D - Puntos y Líneas</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
    
    <script>
      // Componente para cerebro wireframe mejorado
      AFRAME.registerComponent('wireframe-brain', {
        init: function() {
          const el = this.el;
          
          // Crear geometría del cerebro
          const brainGeometry = this.createBrainGeometry();
          
          // Material para las líneas
          const lineMaterial = new THREE.LineBasicMaterial({ 
            color: 0x00FF88,
            linewidth: 1
          });
          
          // Crear el sistema de líneas
          const wireframe = new THREE.LineSegments(brainGeometry, lineMaterial);
          el.object3D.add(wireframe);
          
          // Animación de rotación
          el.setAttribute('animation', {
            property: 'rotation',
            to: '0 360 0',
            loop: true,
            dur: 15000
          });
        },
        
        createBrainGeometry: function() {
          const geometry = new THREE.BufferGeometry();
          const vertices = [];
          const indices = [];
          
          // Crear hemisferio izquierdo
          this.createHemisphere(vertices, indices, -0.4, 0, 0, 0.8);
          // Crear hemisferio derecho  
          this.createHemisphere(vertices, indices, 0.4, 0, 0, 0.8);
          // Crear conexiones entre hemisferios
          this.createConnections(vertices, indices);
          
          geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
          geometry.setIndex(indices);
          
          return geometry;
        },
        
        createHemisphere: function(vertices, indices, offsetX, offsetY, offsetZ, size) {
          const segments = 16;
          const rings = 12;
          const startIndex = vertices.length / 3;
          
          // Crear vértices para el hemisferio
          for (let ring = 0; ring <= rings; ring++) {
            const v = ring / rings;
            const phi = v * Math.PI; // De 0 a PI
            
            for (let segment = 0; segment <= segments; segment++) {
              const u = segment / segments;
              const theta = u * Math.PI * 2; // De 0 a 2PI
              
              // Forma más orgánica (no perfectamente esférica)
              const distortion = 0.8 + Math.sin(theta * 2) * 0.2;
              
              const x = offsetX + Math.sin(phi) * Math.cos(theta) * size * distortion;
              const y = offsetY + Math.cos(phi) * size * 1.2;
              const z = offsetZ + Math.sin(phi) * Math.sin(theta) * size * 0.8;
              
              vertices.push(x, y, z);
            }
          }
          
          // Crear índices para las líneas
          for (let ring = 0; ring < rings; ring++) {
            for (let segment = 0; segment < segments; segment++) {
              const a = startIndex + ring * (segments + 1) + segment;
              const b = startIndex + ring * (segments + 1) + segment + 1;
              const c = startIndex + (ring + 1) * (segments + 1) + segment;
              const d = startIndex + (ring + 1) * (segments + 1) + segment + 1;
              
              // Líneas horizontales (anillos)
              indices.push(a, b);
              // Líneas verticales (segmentos)
              indices.push(a, c);
              
              // Conexiones finales
              if (segment === segments - 1) {
                indices.push(b, d);
              }
              if (ring === rings - 1) {
                indices.push(c, d);
              }
            }
          }
        },
        
        createConnections: function(vertices, indices) {
          const connectionCount = 12;
          const startIndex = vertices.length / 3;
          
          // Crear puntos de conexión entre hemisferios
          for (let i = 0; i < connectionCount; i++) {
            const angle = (i / connectionCount) * Math.PI * 2;
            const height = Math.sin(angle * 2) * 0.3;
            
            // Punto en hemisferio izquierdo
            vertices.push(
              -0.3 + Math.cos(angle) * 0.1,
              height,
              Math.sin(angle) * 0.1
            );
            
            // Punto en hemisferio derecho
            vertices.push(
              0.3 + Math.cos(angle) * 0.1, 
              height,
              Math.sin(angle) * 0.1
            );
            
            // Conectar los puntos
            const leftIdx = startIndex + i * 2;
            const rightIdx = leftIdx + 1;
            indices.push(leftIdx, rightIdx);
          }
        }
      });

      // Componente alternativo - cerebro de puntos más denso
      AFRAME.registerComponent('dense-point-brain', {
        init: function() {
          const el = this.el;
          const points = this.createDensePoints();
          
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
          
          const material = new THREE.PointsMaterial({
            color: 0x88FF00,
            size: 0.008,
            sizeAttenuation: true
          });
          
          const pointCloud = new THREE.Points(geometry, material);
          el.object3D.add(pointCloud);
          
          el.setAttribute('animation', {
            property: 'rotation',
            to: '0 360 0',
            loop: true,
            dur: 12000
          });
        },
        
        createDensePoints: function() {
          const points = [];
          const pointCount = 5000; // Muchos más puntos
          
          for (let i = 0; i < pointCount; i++) {
            const hemisphere = Math.random() < 0.5 ? -1 : 1;
            const u = Math.random();
            const v = Math.random();
            const theta = u * Math.PI * 2;
            const phi = Math.acos(2 * v - 1);
            
            // Forma cerebral más realista
            const distortion = 0.7 + Math.sin(theta * 3) * 0.3;
            const radius = 0.6 * distortion;
            
            const x = hemisphere * 0.4 + Math.sin(phi) * Math.cos(theta) * radius;
            const y = Math.cos(phi) * radius * 1.4;
            const z = Math.sin(phi) * Math.sin(theta) * radius * 0.7;
            
            points.push(x, y, z);
          }
          
          return points;
        }
      });
    </script>
  </head>

  <body>
    <a-scene mindar-image="imageTargetSrc: https://marcebenitez.github.io/ar_web1/data/marker/5markers.mind; maxTrack: 5" 
             color-space="sRGB" 
             renderer="colorManagement: true, physicallyCorrectLights" 
             vr-mode-ui="enabled: false" 
             device-orientation-permission-ui="enabled: false">

      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <!-- Cerebro Wireframe (Opción 1) -->
      <a-entity mindar-image-target="targetIndex: 0">
        <a-entity position="0 0.1 0" scale="1.2 1.2 1.2" wireframe-brain></a-entity>
      </a-entity>

      <!-- Cerebro de Puntos Densos (Opción 2 - comenta/descomenta para probar) -->
      <!--
      <a-entity mindar-image-target="targetIndex: 0">
        <a-entity position="0 0.1 0" scale="0.8 0.8 0.8" dense-point-brain></a-entity>
      </a-entity>
      -->

      <!-- Mantener tus otros modelos existentes -->
      <a-entity mindar-image-target="targetIndex: 1">
        <a-obj-model rotation="90 0 0" position="0 0 0.1" scale="0.008 0.008 0.008" src="https://marcebenitez.github.io/ar_web1/models/polygon_heart.obj" 
                   animation="property: position; to: 0 0.1 0.1; dur: 1000; easing: easeInOutQuad; loop: true; dir: alternate">
        </a-obj-model>
      </a-entity>

    </a-scene>
  </body>
</html>
