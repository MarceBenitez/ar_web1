<html>
  <head>
    <title>Cerebro 3D Realista</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.2/dist/mindar-image-aframe.prod.js"></script>
    
    <script>
      // Componente para cerebro con forma más realista
      AFRAME.registerComponent('realistic-brain', {
        init: function() {
          const el = this.el;
          
          // Crear geometría del cerebro realista
          const brainGeometry = this.createRealisticBrainGeometry();
          
          // Material para las líneas
          const lineMaterial = new THREE.LineBasicMaterial({ 
            color: 0x4A90E2,
            linewidth: 1
          });
          
          // Crear el sistema de líneas
          const wireframe = new THREE.LineSegments(brainGeometry, lineMaterial);
          el.object3D.add(wireframe);
          
          // Animación de rotación
          el.setAttribute('animation', {
            property: 'rotation',
            to: '0 360 0',
            loop: true,
            dur: 20000
          });
        },
        
        createRealisticBrainGeometry: function() {
          const geometry = new THREE.BufferGeometry();
          const vertices = [];
          const indices = [];
          
          // Crear hemisferio izquierdo con más detalle
          this.createBrainHemisphere(vertices, indices, -0.5);
          // Crear hemisferio derecho
          this.createBrainHemisphere(vertices, indices, 0.5);
          // Crear cuerpo calloso (conexión entre hemisferios)
          this.createCorpusCallosum(vertices, indices);
          
          geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
          geometry.setIndex(indices);
          
          return geometry;
        },
        
        createBrainHemisphere: function(vertices, indices, xOffset) {
          const segments = 20;
          const layers = 10;
          const startIndex = vertices.length / 3;
          
          // Crear múltiples capas para simular circunvoluciones
          for (let layer = 0; layer <= layers; layer++) {
            const layerProgress = layer / layers;
            
            for (let segment = 0; segment <= segments; segment++) {
              const segmentProgress = segment / segments;
              const angle = segmentProgress * Math.PI; // Solo medio círculo para forma cerebral
              
              // Base de la forma cerebral (más plana en la parte inferior)
              let radius = 0;
              let y = 0;
              let z = 0;
              
              if (layerProgress < 0.3) {
                // Lóbulo frontal
                radius = 0.7 * (1 - Math.pow(layerProgress - 0.15, 2) * 3);
                y = layerProgress * 1.2 - 0.6;
                z = Math.sin(angle * 1.5) * radius * 0.8;
              } else if (layerProgress < 0.7) {
                // Parte central - más ancha
                radius = 0.8 * (1 - Math.pow(layerProgress - 0.5, 2) * 2);
                y = layerProgress * 1.2 - 0.6;
                z = Math.sin(angle) * radius;
              } else {
                // Lóbulo occipital
                radius = 0.6 * (1 - Math.pow(layerProgress - 0.85, 2) * 4);
                y = layerProgress * 1.2 - 0.6;
                z = Math.sin(angle * 0.8) * radius * 1.1;
              }
              
              // Agregar irregularidades para simular circunvoluciones
              const irregularity = Math.sin(segment * 3) * 0.1 + Math.cos(layer * 4) * 0.05;
              radius += irregularity * 0.2;
              
              const x = xOffset + Math.cos(angle) * radius * (xOffset > 0 ? -1 : 1);
              
              vertices.push(x, y, z);
            }
          }
          
          // Conectar los puntos con líneas
          for (let layer = 0; layer < layers; layer++) {
            for (let segment = 0; segment < segments; segment++) {
              const a = startIndex + layer * (segments + 1) + segment;
              const b = startIndex + layer * (segments + 1) + segment + 1;
              const c = startIndex + (layer + 1) * (segments + 1) + segment;
              const d = startIndex + (layer + 1) * (segments + 1) + segment + 1;
              
              // Líneas horizontales
              indices.push(a, b);
              // Líneas verticales
              indices.push(a, c);
              
              // Conexiones diagonales para mejor definición
              if (segment === segments - 1) {
                indices.push(b, d);
              }
              if (layer === layers - 1) {
                indices.push(c, d);
              }
            }
          }
        },
        
        createCorpusCallosum: function(vertices, indices) {
          // Crear la conexión entre hemisferios (cuerpo calloso)
          const connectionPoints = 8;
          const startIndex = vertices.length / 3;
          
          for (let i = 0; i <= connectionPoints; i++) {
            const progress = i / connectionPoints;
            const angle = progress * Math.PI - Math.PI / 2;
            
            const x = Math.cos(angle) * 0.3;
            const y = Math.sin(angle) * 0.4;
            const z = 0;
            
            vertices.push(x, y, z);
          }
          
          // Conectar los puntos del cuerpo calloso
          for (let i = 0; i < connectionPoints; i++) {
            indices.push(startIndex + i, startIndex + i + 1);
          }
        }
      });

      // Componente alternativo - cerebro de puntos con forma más anatómica
      AFRAME.registerComponent('anatomical-brain-points', {
        init: function() {
          const el = this.el;
          const points = this.createAnatomicalPoints();
          
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
          
          const material = new THREE.PointsMaterial({
            color: 0x00AAFF,
            size: 0.005,
            sizeAttenuation: true
          });
          
          const pointCloud = new THREE.Points(geometry, material);
          el.object3D.add(pointCloud);
          
          el.setAttribute('animation', {
            property: 'rotation',
            to: '0 360 0',
            loop: true,
            dur: 18000
          });
        },
        
        createAnatomicalPoints: function() {
          const points = [];
          const pointCount = 8000;
          
          for (let i = 0; i < pointCount; i++) {
            const hemisphere = Math.random() < 0.5 ? -1 : 1;
            
            // Distribución más anatómica
            const u = Math.random();
            const v = Math.random();
            
            let x, y, z;
            
            if (u < 0.4) {
              // Lóbulo frontal
              x = hemisphere * (0.3 + Math.random() * 0.4);
              y = 0.2 + Math.random() * 0.4;
              z = (Math.random() - 0.5) * 0.6;
            } else if (u < 0.7) {
              // Lóbulo parietal (parte superior)
              x = hemisphere * (0.2 + Math.random() * 0.3);
              y = 0.6 + Math.random() * 0.3;
              z = (Math.random() - 0.5) * 0.5;
            } else {
              // Lóbulo occipital (parte posterior)
              x = hemisphere * (0.1 + Math.random() * 0.3);
              y = 0.3 + Math.random() * 0.4;
              z = -0.3 - Math.random() * 0.4;
            }
            
            // Agregar algunos puntos en el cuerpo calloso
            if (Math.random() < 0.1) {
              x = (Math.random() - 0.5) * 0.6;
              y = 0.4 + (Math.random() - 0.5) * 0.2;
              z = 0;
            }
            
            points.push(x, y, z);
          }
          
          return points;
        }
      });
    </script>
  </head>

  <body>
    <a-scene mindar-image="imageTargetSrc: https://marcebenitez.github.io/ar_web1/data/marker/5markers.mind; maxTrack: 5" 
             color-space="sRGB" 
             renderer="colorManagement: true, physicallyCorrectLights" 
             vr-mode-ui="enabled: false" 
             device-orientation-permission-ui="enabled: false">

      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <!-- Cerebro Realista Wireframe (Recomendado) -->
      <a-entity mindar-image-target="targetIndex: 0">
        <a-entity position="0 0.2 0" scale="1.5 1.5 1.5" realistic-brain></a-entity>
      </a-entity>

      <!-- Cerebro Anatómico de Puntos (Alternativa) -->
      <!--
      <a-entity mindar-image-target="targetIndex: 0">
        <a-entity position="0 0.2 0" scale="1.2 1.2 1.2" anatomical-brain-points></a-entity>
      </a-entity>
      -->

    </a-scene>
  </body>
</html>
